"use strict";
var __importDefault =
  (this && this.__importDefault) ||
  function (mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebsocketClient = exports.DefaultChannels = exports.WsUri = void 0;
const ws_1 = __importDefault(require("ws"));
const events_1 = require("events");
const signer_1 = require("./signer");
const currencies_1 = require("./currencies");
const currencypairs_1 = require("./currencypairs");
exports.WsUri = "wss://api2.poloniex.com";
exports.DefaultChannels = [121];
class WebsocketClient extends events_1.EventEmitter {
  /**
   * Create WebsocketClient.
   */
  constructor({
    wsUri = exports.WsUri,
    raw = true,
    channels = exports.DefaultChannels,
    key,
    secret,
  } = {}) {
    super();
    this.raw = raw;
    this.channels = channels;
    this.#nonce = () => Date.now();
    this.wsUri = wsUri;
    if (key && secret) {
      this.#key = key;
      this.#secret = secret;
    }
  }
  #key;
  #secret;
  #nonce;
  /**
   * Connect to the websocket.
   */
  async connect() {
    switch (this.ws?.readyState) {
      case ws_1.default.CLOSING:
      case ws_1.default.CONNECTING:
        throw new Error(`Could not connect. State: ${this.ws.readyState}`);
      case ws_1.default.OPEN:
        return;
      default:
        break;
    }
    await new Promise((resolve, reject) => {
      this.ws = new ws_1.default(this.wsUri);
      this.ws.once("open", resolve);
      this.ws.once("error", reject);
      this.ws.on("open", () => {
        this.emit("open");
        for (const channel of this.channels) {
          this.subscribe(channel).catch((error) => {
            this.emit("error", error);
          });
        }
      });
      this.ws.on("close", () => {
        this.emit("close");
      });
      this.ws.on("message", (data) => {
        try {
          const jsondata = JSON.parse(data);
          if ("error" in jsondata) {
            this.emit("error", jsondata);
            return;
          }
          if (this.raw) {
            this.emit("rawMessage", jsondata);
          }
          if (jsondata.length === 1) {
            const message = WebsocketClient.formatHeartbeat(jsondata);
            this.emit("message", message);
          } else if (jsondata.length === 2) {
            const message = WebsocketClient.formatAcknowledge(jsondata);
            this.emit("message", message);
          } else if (jsondata[1] === null && jsondata[0] === 1002) {
            const message = WebsocketClient.formatTicker(jsondata);
            this.emit("message", message);
          } else if (jsondata[1] === null && jsondata[0] === 1003) {
            const message = WebsocketClient.formatVolume(jsondata);
            this.emit("message", message);
          } else if (
            (jsondata[1] === "" || jsondata[1] === null) &&
            jsondata[0] === 1000
          ) {
            const messages = WebsocketClient.formatAccount(jsondata);
            for (const message of messages) {
              this.emit("message", message);
            }
          } else {
            const messages = WebsocketClient.formatUpdate(jsondata);
            for (const message of messages) {
              this.emit("message", message);
            }
          }
        } catch (error) {
          this.emit("error", error);
        }
      });
      this.ws.on("error", (error) => {
        if (error) {
          this.emit("error", error);
        }
      });
    });
  }
  /**
   * Disconnect from the websocket.
   */
  async disconnect() {
    switch (this.ws?.readyState) {
      case ws_1.default.CLOSED:
        return;
      case ws_1.default.CLOSING:
      case ws_1.default.CONNECTING:
        throw new Error(`Could not disconnect. State: ${this.ws.readyState}`);
      default:
        break;
    }
    await new Promise((resolve, reject) => {
      if (!this.ws) {
        resolve();
        return;
      }
      this.ws.once("error", reject);
      this.ws.once("close", resolve);
      this.ws.close();
    });
  }
  /**
   * Subscribes to the specified channel.
   */
  async subscribe(channel) {
    await this.send({ command: "subscribe", channel });
  }
  /**
   * Unsubscribes from the specified channel.
   */
  async unsubscribe(channel) {
    await this.send({ command: "unsubscribe", channel });
  }
  async send(subscription) {
    const { ws } = this;
    if (!ws) {
      throw new Error("Websocket is not initialized");
    }
    let message = { ...subscription };
    if (this.#key && this.#secret) {
      const form = new URLSearchParams({ nonce: `${this.nonce()}` });
      const payload = form.toString();
      const signature = signer_1.SignRequest({
        key: this.#key,
        secret: this.#secret,
        body: payload,
      });
      message = { ...message, payload, ...signature };
    }
    await new Promise((resolve, reject) => {
      ws.send(JSON.stringify(message), (error) => {
        if (error) {
          reject(error);
        } else {
          resolve();
        }
      });
    });
  }
  static formatTicker([
    channel_id,
    ,
    [
      currencyPairId,
      last,
      lowestAsk,
      highestBid,
      percentChange,
      baseVolume,
      quoteVolume,
      isFrozen,
      high24hr,
      low24hr,
    ],
  ]) {
    return {
      subject: "ticker",
      channel_id,
      currencyPairId,
      currencyPair: currencypairs_1.CurrencyPairs[currencyPairId],
      last,
      lowestAsk,
      highestBid,
      percentChange,
      baseVolume,
      quoteVolume,
      isFrozen: isFrozen ? true : false,
      high24hr,
      low24hr,
    };
  }
  static formatVolume([channel_id, , [time, users, volume]]) {
    return { subject: "volume", channel_id, time, users, volume };
  }
  static formatSnapshot([, { currencyPair, orderBook }]) {
    const [asks, bids] = orderBook;
    return { subject: "snapshot", currencyPair, asks, bids };
  }
  static formatPublicTrade([, tradeID, side, price, size, timestamp]) {
    const type = side === 1 ? "buy" : "sell";
    return { subject: "publicTrade", tradeID, type, price, size, timestamp };
  }
  static formatBookUpdate([, side, price, size]) {
    const type = side === 1 ? "bid" : "ask";
    return { subject: "update", type, price, size };
  }
  static formatHeartbeat([channel_id]) {
    return { subject: "heartbeat", channel_id };
  }
  static formatAcknowledge([channel_id, sequence]) {
    const subject = sequence ? "subscribed" : "unsubscribed";
    return { subject, channel_id };
  }
  static formatUpdate([channel_id, sequence, messages]) {
    const output = [];
    const currencyPair = currencypairs_1.CurrencyPairs[channel_id];
    for (const message of messages) {
      if (message[0] === "i") {
        const msg = WebsocketClient.formatSnapshot(message);
        output.push({ channel_id, sequence, ...msg });
      } else if (message[0] === "t") {
        const msg = WebsocketClient.formatPublicTrade(message);
        output.push({
          currencyPair,
          channel_id,
          sequence,
          ...msg,
        });
      } else {
        const msg = WebsocketClient.formatBookUpdate(message);
        output.push({ currencyPair, channel_id, sequence, ...msg });
      }
    }
    return output;
  }
  static formatPending([
    ,
    orderNumber,
    currencyPairId,
    rate,
    amount,
    type,
    clientOrderId,
  ]) {
    return {
      subject: "pending",
      orderNumber,
      currencyPairId,
      currencyPair: currencypairs_1.CurrencyPairs[currencyPairId],
      rate,
      amount,
      type: type === "0" ? "sell" : "buy",
      clientOrderId,
    };
  }
  static formatNew([
    ,
    currencyPairId,
    orderNumber,
    type,
    rate,
    amount,
    date,
    originalAmount,
    clientOrderId,
  ]) {
    return {
      subject: "new",
      currencyPairId,
      currencyPair: currencypairs_1.CurrencyPairs[currencyPairId],
      orderNumber,
      type: type === "0" ? "sell" : "buy",
      rate,
      amount,
      date,
      originalAmount,
      clientOrderId,
    };
  }
  static formatBalance([, currencyId, w, amount]) {
    const wallet = w === "e" ? "exchange" : w === "m" ? "margin" : "lending";
    const currency = currencies_1.Currencies[currencyId];
    return { subject: "balance", currencyId, currency, wallet, amount };
  }
  static formatOrder([, orderNumber, newAmount, t, clientOrderId]) {
    const subject = "order";
    const orderType =
      t === "f" ? "filled" : t === "c" ? "canceled" : "self-trade";
    return { subject, orderNumber, newAmount, orderType, clientOrderId };
  }
  static formatMarginUpdate([, orderNumber, currency, amount, clientOrderId]) {
    const subject = "margin";
    return {
      subject,
      orderNumber,
      currency: currencies_1.Currencies[currency] ?? `${currency}`,
      amount,
      clientOrderId,
    };
  }
  static formatTrade([
    ,
    tradeID,
    rate,
    amount,
    feeMultiplier,
    fundingType,
    orderNumber,
    fee,
    date,
    clientOrderId,
  ]) {
    return {
      subject: "trade",
      tradeID,
      rate,
      amount,
      feeMultiplier,
      fundingType,
      orderNumber,
      fee,
      date,
      clientOrderId,
    };
  }
  static formatKill([, orderNumber, clientOrderId]) {
    return { subject: "killed", orderNumber, clientOrderId };
  }
  static formatAccount([channel_id, , messages]) {
    const output = [];
    for (const message of messages) {
      if (message[0] === "p") {
        const msg = WebsocketClient.formatPending(message);
        output.push({ channel_id, ...msg });
      } else if (message[0] === "n") {
        const msg = WebsocketClient.formatNew(message);
        output.push({ channel_id, ...msg });
      } else if (message[0] === "b") {
        const msg = WebsocketClient.formatBalance(message);
        output.push({ channel_id, ...msg });
      } else if (message[0] === "o") {
        const msg = WebsocketClient.formatOrder(message);
        output.push({ channel_id, ...msg });
      } else if (message[0] === "m") {
        const msg = WebsocketClient.formatMarginUpdate(message);
        output.push({ channel_id, ...msg });
      } else if (message[0] === "t") {
        const msg = WebsocketClient.formatTrade(message);
        output.push({ channel_id, ...msg });
      } else if (message[0] === "k") {
        const msg = WebsocketClient.formatKill(message);
        output.push({ channel_id, ...msg });
      }
    }
    return output;
  }
  set nonce(nonce) {
    this.#nonce = nonce;
  }
  get nonce() {
    return this.#nonce;
  }
}
exports.WebsocketClient = WebsocketClient;
